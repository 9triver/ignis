package main

import (
	"encoding/base64"
	"errors"
	"reflect"
)

type MapHook func(dstType, srcType reflect.Type, v any) (any, error)

var (
	base64Hook MapHook = func(dstType, srcType reflect.Type, v any) (any, error) {
		if dstType == reflect.TypeFor[[]byte]() && srcType.Kind() == reflect.String {
			decoded, err := base64.StdEncoding.DecodeString(v.(string))
			if err != nil {
				return nil, err
			}
			return decoded, nil
		}
		return nil, nil
	}

	chanConvertHook MapHook = func(dstType, srcType reflect.Type, v any) (any, error) {
		if dstType.Kind() == reflect.Chan && srcType.Kind() == reflect.Chan {
			if dstType.Elem() == srcType.Elem() {
				return v, nil
			}

			vch := reflect.ValueOf(v)
			ch := reflect.MakeChan(reflect.ChanOf(reflect.BothDir, dstType.Elem()), 10)
			go func() {
				defer ch.Close()
				for {
					elem, ok := vch.Recv()
					if !ok {
						return
					}
					// TODO: make workaround more generic
					var value reflect.Value
					if o, ok := elem.Interface().(interface {
						GetValue() (any, error) // cannot import Object interface due to circular dependencies
					}); ok {
						v, err := o.GetValue()
						if err != nil {
							return
						}
						value = reflect.ValueOf(v)
					} else {
						value = elem.Elem()
					}
					ch.Send(value.Convert(dstType.Elem()))
				}
			}()
			return ch.Interface(), nil
		}

		return nil, nil
	}

	hooks = []MapHook{base64Hook, chanConvertHook}
)

func MapToStruct[I any](invoke map[string]any) (ret I, err error) {
	var input I

	t := reflect.TypeFor[I]()

	var it reflect.Type
	if t.Kind() == reflect.Pointer {
		input = reflect.New(t.Elem()).Interface().(I)
		it = t.Elem()
	}

	if it.Kind() != reflect.Struct {
		err = errors.New("output type is not a struct")
		return
	}

	var v reflect.Value
	if t.Kind() == reflect.Pointer {
		v = reflect.ValueOf(input)
	} else {
		v = reflect.ValueOf(&input)
	}

	for i := range it.NumField() {
		fieldValue := v.Elem().Field(i)
		field := it.Field(i)

		if v, ok := invoke[field.Name]; ok {
			valueType := reflect.TypeOf(v)

			for _, hook := range hooks {
				converted, err := hook(field.Type, valueType, v)
				if err != nil {
					return ret, err
				}
				if converted != nil {
					v = converted
					break
				}
			}

			fieldValue.Set(reflect.ValueOf(v).Convert(field.Type))
		}
	}

	return input, nil
}

func Call(invoke map[string]any) (any, error) {
	params, err := MapToStruct[*Input](invoke)
	if err != nil {
		return nil, err
	}

	return Impl(params)
}
